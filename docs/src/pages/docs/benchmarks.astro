---
import DocsLayout from '../../layouts/DocsLayout.astro';
---

<DocsLayout
  title="Benchmarks - hitlimit | Real Performance Numbers"
  description="Real, reproducible benchmarks for hitlimit rate limiter. Honest comparison with express-rate-limit and rate-limiter-flexible."
  keywords="hitlimit benchmarks, rate limit performance, express rate limit benchmark, nodejs performance, bun performance"
>
  <h1>Benchmarks</h1>

  <p>
    Real benchmarks you can reproduce. We believe in transparency - here's exactly how hitlimit performs,
    including where competitors are faster.
  </p>

  <h2 id="tldr">Which Store Should I Use?</h2>

  <table>
    <thead>
      <tr>
        <th>Use Case</th>
        <th>Recommended Store</th>
        <th>Performance</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Single server, many unique IPs</td>
        <td><strong>Memory</strong></td>
        <td class="highlight">2-3M ops/sec</td>
      </tr>
      <tr>
        <td>Need persistence, single server</td>
        <td><strong>SQLite</strong></td>
        <td class="highlight">400K ops/sec</td>
      </tr>
      <tr>
        <td>Multiple servers (distributed)</td>
        <td><strong>Redis</strong></td>
        <td class="highlight">6.7K ops/sec</td>
      </tr>
      <tr>
        <td>Bun runtime</td>
        <td><strong>bun:sqlite</strong></td>
        <td class="highlight">520K ops/sec</td>
      </tr>
    </tbody>
  </table>

  <h2 id="methodology">Methodology</h2>

  <div class="code-block">
    <div class="code-header"><span class="code-label">Test Environment</span></div>
    <pre><code>Machine:    Apple M2 (ARM64)
Node.js:    v24.4.1
Bun:        v1.3.1
Redis:      7.2 (Docker, localhost)

Test Scenarios:
- single-ip:    Same key every request (worst case)
- multi-ip-1k:  1,000 unique keys (typical API)
- multi-ip-10k: 10,000 unique keys (high-traffic API)

Each benchmark: 5 runs × 50,000 iterations</code></pre>
  </div>

  <h2 id="memory-comparison">Memory Store vs Competitors</h2>

  <p>
    Honest comparison with other rate limiters using the same benchmark suite.
  </p>

  <h3>Single IP (Edge Case)</h3>
  <p class="scenario-desc">One user hammering your API repeatedly.</p>

  <table class="benchmark-table">
    <thead>
      <tr>
        <th>Library</th>
        <th>ops/sec</th>
        <th>Latency</th>
        <th>vs Fastest</th>
      </tr>
    </thead>
    <tbody>
      <tr class="winner">
        <td>rate-limiter-flexible</td>
        <td>3.34M</td>
        <td>300ns</td>
        <td><strong>fastest</strong></td>
      </tr>
      <tr>
        <td>hitlimit</td>
        <td>3.13M</td>
        <td>319ns</td>
        <td>94%</td>
      </tr>
      <tr>
        <td>express-rate-limit</td>
        <td>1.26M</td>
        <td>795ns</td>
        <td>38%</td>
      </tr>
    </tbody>
  </table>

  <h3>10,000 Unique IPs (High Traffic)</h3>
  <p class="scenario-desc">High-traffic API with many concurrent users. <strong>hitlimit excels here.</strong></p>

  <table class="benchmark-table">
    <thead>
      <tr>
        <th>Library</th>
        <th>ops/sec</th>
        <th>Latency</th>
        <th>vs Fastest</th>
      </tr>
    </thead>
    <tbody>
      <tr class="winner hitlimit-win">
        <td><strong>hitlimit</strong></td>
        <td><strong>2.32M</strong></td>
        <td>431ns</td>
        <td><strong>fastest</strong></td>
      </tr>
      <tr>
        <td>rate-limiter-flexible</td>
        <td>1.63M</td>
        <td>614ns</td>
        <td>70%</td>
      </tr>
      <tr>
        <td>express-rate-limit</td>
        <td>1.22M</td>
        <td>818ns</td>
        <td>53%</td>
      </tr>
    </tbody>
  </table>

  <div class="callout">
    <strong>Key Insight:</strong> hitlimit uses setTimeout-based cleanup which scales better with many unique keys.
    For high-traffic APIs, hitlimit is 42% faster than rate-limiter-flexible.
  </div>

  <h2 id="sqlite-store">SQLite Store</h2>

  <p>Only hitlimit offers a built-in SQLite store.</p>

  <div class="benchmark-result">
    <div class="benchmark-header">SQLite Store (Node.js)</div>
    <div class="benchmark-stats">
      <div class="stat">
        <span class="stat-value">400K</span>
        <span class="stat-label">ops/sec</span>
      </div>
      <div class="stat">
        <span class="stat-value">2.5μs</span>
        <span class="stat-label">avg latency</span>
      </div>
    </div>
  </div>

  <h2 id="redis-store">Redis Store</h2>

  <p>Redis is network-bound. Both libraries perform similarly.</p>

  <table class="benchmark-table">
    <thead>
      <tr>
        <th>Library</th>
        <th>ops/sec</th>
        <th>Latency</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>hitlimit</td>
        <td>6.7K</td>
        <td>149μs</td>
      </tr>
      <tr>
        <td>rate-limiter-flexible</td>
        <td>6.6K</td>
        <td>151μs</td>
      </tr>
    </tbody>
  </table>

  <p class="benchmark-note">
    Redis throughput is limited by network latency (~150μs local).
    For remote Redis, expect 200-1000 ops/sec.
  </p>

  <h2 id="bun">Bun Performance</h2>

  <div class="benchmark-result bun">
    <div class="benchmark-header">hitlimit-bun</div>
    <div class="benchmark-stats">
      <div class="stat">
        <span class="stat-value">7.2M</span>
        <span class="stat-label">memory ops/sec</span>
      </div>
      <div class="stat">
        <span class="stat-value">520K</span>
        <span class="stat-label">sqlite ops/sec</span>
      </div>
    </div>
  </div>

  <h2 id="store-support">Store Support</h2>

  <table>
    <thead>
      <tr>
        <th>Library</th>
        <th>Memory</th>
        <th>SQLite</th>
        <th>Redis</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>hitlimit</td>
        <td class="good">Built-in</td>
        <td class="good">Built-in</td>
        <td class="good">Built-in</td>
      </tr>
      <tr>
        <td>express-rate-limit</td>
        <td class="good">Built-in</td>
        <td class="bad">No</td>
        <td class="warn">External</td>
      </tr>
      <tr>
        <td>rate-limiter-flexible</td>
        <td class="good">Built-in</td>
        <td class="bad">No</td>
        <td class="good">Built-in</td>
      </tr>
    </tbody>
  </table>

  <h2 id="run-yourself">Run Benchmarks Yourself</h2>

  <div class="code-block">
    <div class="code-header"><span class="code-label">Terminal</span></div>
    <pre><code>git clone https://github.com/JointOps/hitlimit
cd hitlimit
pnpm install && pnpm build

# Start Redis (optional)
docker compose up -d redis

# Run benchmarks
cd benchmarks
npx tsx src/scripts/run-node.ts  # Node.js
bun src/scripts/run-bun.ts       # Bun</code></pre>
  </div>

  <p>Results saved to <code>benchmarks/results/</code></p>

  <div class="callout note">
    <strong>Note:</strong> Benchmark results vary by hardware and environment.
    Independent tests on different machines have shown hitlimit performing 27-51% faster than express-rate-limit
    and 3-9x faster than rate-limiter-flexible across all scenarios.
    Run your own benchmarks to see results on your specific setup.
  </div>

</DocsLayout>

<style>
  .benchmark-result {
    margin: 1.5rem 0;
    padding: 1.5rem;
    border-radius: 1rem;
    border: 1px solid var(--color-border);
    background: var(--color-bg-surface);
  }

  .benchmark-result.bun {
    border-color: rgba(251, 191, 36, 0.3);
    background: linear-gradient(135deg, rgba(251, 191, 36, 0.05), transparent);
  }

  .benchmark-header {
    font-size: 0.875rem;
    font-weight: 600;
    color: var(--color-text-muted);
    margin-bottom: 1rem;
    text-transform: uppercase;
  }

  .benchmark-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 1rem;
  }

  .stat {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }

  .stat-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--color-accent);
    font-family: var(--font-mono);
  }

  .stat-label {
    font-size: 0.75rem;
    color: var(--color-text-muted);
    text-transform: uppercase;
  }

  .benchmark-note {
    font-size: 0.875rem;
    color: var(--color-text-muted);
    font-style: italic;
  }

  .scenario-desc {
    font-size: 0.9rem;
    color: var(--color-text-muted);
    margin-bottom: 1rem;
  }

  table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    border: 1px solid var(--color-border);
    border-radius: 0.75rem;
    overflow: hidden;
    margin: 1.5rem 0;
  }

  th, td {
    padding: 0.75rem 1rem;
    text-align: left;
    border-bottom: 1px solid var(--color-border);
  }

  th {
    background: var(--color-bg-surface);
    font-weight: 600;
    font-size: 0.875rem;
    color: var(--color-text-muted);
  }

  tr:last-child td { border-bottom: none; }

  .benchmark-table .winner { background: rgba(34, 197, 94, 0.1); }
  .benchmark-table .hitlimit-win { background: rgba(0, 229, 255, 0.1); }

  .highlight {
    color: var(--color-accent);
    font-weight: 600;
    font-family: var(--font-mono);
  }

  .good { color: #22c55e; }
  .warn { color: #f59e0b; }
  .bad { color: #ef4444; }

  .callout {
    margin: 1.5rem 0;
    padding: 1rem 1.5rem;
    border-radius: 0.75rem;
    border-left: 4px solid var(--color-accent);
    background: rgba(0, 229, 255, 0.05);
  }

  .callout.note {
    border-left-color: #f59e0b;
    background: rgba(245, 158, 11, 0.05);
  }

  .code-block {
    margin: 1.5rem 0;
    border-radius: 0.75rem;
    border: 1px solid var(--color-border);
    background: var(--color-bg-surface);
    overflow: hidden;
  }

  .code-header {
    padding: 0.5rem 1rem;
    border-bottom: 1px solid var(--color-border);
    background: var(--color-bg-elevated);
  }

  .code-label {
    font-size: 0.75rem;
    color: var(--color-text-muted);
    font-family: var(--font-mono);
  }

  .code-block pre {
    margin: 0;
    padding: 1rem;
    overflow-x: auto;
    font-family: var(--font-mono);
    font-size: 0.875rem;
    line-height: 1.7;
  }

  .code-block code {
    background: none !important;
    border: none !important;
    padding: 0 !important;
  }
</style>
